# wb-tasks-1
Задачки на знание многопоточности, алгоритмов, структур данных в Golang

### Ответы на устные вопросы
1. StringBuilder
2. Интерфейсы - инструменты, определяющие поведение реализующих их структур
3. RWMutex содержит методы Rlock и Runlock. Они блокируют читаемые данные от записи в них новых значений
4. Буферизированные каналы имеют буфер для соответствующих значений и блокируется для записи тогда, когда буфер полон
5. sizeof struct{}{} = 0
6. В golang нет перегрузки методов и операторов
7. m[0]=1 m[1]=124 m[2]=281 - последовательность вывода неизвестна. Мапа работает на основе хеш фунции => финальный порядок элементов неизвестен
8. make - функция для создания слайсов, мап и каналов + она не возвращает указатель
   new - функция, возвращающая указатель на создаваемую структуру
9. make
   append - добавляет элемент в слайс и возвращает новый при расширении
   слайс на основе массива или другого слайса arr[1:3]
   var sl []string
   var m map[string]string
   s := []int {1, 2, 3}
   s := []rune ("aboba")
   m := map[int]int { 1 : 1 }
10. deadlock. Создалась копия waitGroup. Исходная wg не знает, что горутины вызывают wg.Done. Нужно передавать по ссылке
11. Выведет 1 \n 1. Первая 1 очевидно - разыменованный указатель укажет на область памяти, куда он направлен. При вызове фунций в go в аргументы передается копия объекта. Так копия указателя начинает указывать на b, а исходный указатель все еще направлен на a
12. Выведет 0. Оператор := создал новую переменную n в теле if. Изменения этой переменной не имеют никакого отношения к исходному n
13. Выведет [100, 2, 3, 4, 5]. Как говорилось ранее в go передается по значению. В данном случае значение - slice header, содержащий указатель на выделенную память, cap и len. При v[0]=100 по указателю в памяти меняется 0-й элемент. append же изменяет len и cap (при необходимости). Исходный слайс не знает о изменении этих параметров внутри себя, они остаются прежними и расширения слайса не наблюдается 
14. В данном случае append создал новый слайс и память исходного и того, что внутри фунции разделилась. Так вывод - [b, b, a][a, a]
