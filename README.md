# wb-tasks-1
Задачки на знание многопоточности, алгоритмов, структур данных в Golang

### Ответы на устные вопросы
1. StringBuilder
2. Интерфейсы - инструменты, определяющие поведение реализующих их структур
3. RWMutex содержит методы Rlock и Runlock. Они блокируют читаемые данные от записи в них новых значений
4. Буферизированные каналы имеют буфер для соответствующих значений и блокируется для записи тогда, когда буфер полон
5. sizeof struct{}{} = 0
6. В golang нет перегрузки методов и операторов
7. m[0]=1 m[1]=124 m[2]=281 - последовательность вывода неизвестна. Мапа работает на основе хеш фунции => финальный порядок элементов неизвестен
8. make - функция для создания слайсов, мап и каналов + она не возвращает указатель
   new - функция, возвращающая указатель на создаваемую структуру
10. make()
    слайс на основе массива или другого слайса arr[1:3]
    append - добавляет элемент в слайс и возвращает новый
    var item []string (map[string] string)
    item := []strint {1, 2, 3, 4}
    item := map[string]string{ "a":"a" }
11. Выведет 1 \n 1. Первая 1 очевидно - разыменованный указатель укажет на область памяти, куда он направлен. При вызове фунций в go в аргументы передается копия объекта. Так копия указателя начинает указывать на b, а исходный указатель все еще направлен на a
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
12. Выведет 0. Оператор := создал новую переменную n в теле if. Изменения этой переменной не имеют никакого отношения к исходному n
  func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
13. Выведет [100, 2, 3, 4, 5]. Как говорилось ранее в go передается по значению. В данном случае значение - slice header, содержащий указатель на выделенную память, cap и len. При v[0]=100 по указателю в памяти меняется 0-й элемент. append же изменяет len и cap (при необходимости). Исходный слайс не знает о изменении этих параметров внутри себя, они остаются прежними и расширения слайса не наблюдается 
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
14. В данном случае append создал новый слайс и память исходного и того, что внутри фунции разделилась. Так вывод - [b, b, a][a, a]
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
